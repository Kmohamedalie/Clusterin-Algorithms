# -*- coding: utf-8 -*-
"""K Means and Elbow Method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kHqLYKeK2h3W7-fIY9LGOcQnwtikEQn7

# **Basics of cluster analysis**

Credits to [365 Data Science](https://www.youtube.com/watch?v=YIGtalP1mv0)


Data [github](https://github.com/timurista/data-analysis/blob/master/python-jupyter/Cluster%20Analysis/3.01.%20Country%20clusters.csv)

### Import the relevant libraries
"""

# import visualization and data wrangling libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
# import the KMeans algorithms from sklearn.cluster
from sklearn.cluster import KMeans

"""### Load the data"""

# read the data
data = pd.read_csv('3.01. Country clusters.csv')

# view the data
data

"""### Plot the data"""

# plot the clusters with the actual latitudes and longitudes
plt.scatter(data['Longitude'], data['Latitude'])
plt.xlim(-180,180)
plt.ylim(-90,90)
plt.title('Country scatter plot')
plt.show();

"""### Select the features"""

# start clustering based on location using latitude and longitude
x = data.iloc[:,1:3] # as the features to x

# output x
x

"""### Clustering"""

# declare KMeans variable
 # 2 number of clusters we want
kmeans = KMeans(n_clusters=3, n_init='auto')

# fit the variable
kmeans.fit(x)

"""### Clustering results"""

# interested in the cluster and predicted value of the algorithm
identified_clusters = kmeans.fit_predict(x)
identified_clusters

# new dataFrame with cluster value of each country
data_with_cluster = data.copy()
# new column assigned
data_with_cluster['Cluster'] = identified_clusters
# output the new dataFrame
data_with_cluster

# plot the clusters with the actual latitudes and longitudes
plt.scatter(data['Longitude'], data['Latitude'], c=data_with_cluster['Cluster'],cmap='rainbow')
plt.xlim(-180,180)
plt.ylim(-90,90)
plt.title('Country clusters')
plt.show();

"""### **Silhouette score of our K-Means:**"""

# import silhouette_score from sklearn
from sklearn.metrics import silhouette_score
# the variable and predicted identified clusters
silhouette_score(x,identified_clusters)

"""## **Now let's cluster based on language**"""

data

"""### using the language feature"""

# make a copy of the data and assign to the variable data_lang
data_lang = data_with_cluster.copy()
# use the map function to encode the language feature
# Note other more efficient methods sure binarization and one-hot-encoding can be used
data_lang['Language'] = data_lang['Language'].map({'English':0, 'French':1, 'German':2})

data_lang

"""#### cluster with language"""

# plot the clusters with the actual latitudes and longitudes
plt.scatter(data_lang['Longitude'], data_lang['Latitude'], c=data_lang['Language'],cmap='rainbow')
plt.xlim(-180,180)
plt.ylim(-90,90)
plt.title('Country clusters with language')
plt.show();

"""# **Elbow Method:**

**The elbow method:** is a graphical representation of finding the optimal 'K' in a K-means clustering. It works by finding WCSS (Within-Cluster Sum of Square) i.e. the sum of the square distance between points in a cluster and the cluster centroid.<br/>


**WCSS:** is the sum of the squared distance between each point and the centroid in a cluster. When we plot the WCSS with the K value, the plot looks like an Elbow. As the number of clusters increases, the WCSS value will start to decrease. WCSS value is largest when K = 1.

[WCSS](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FWCSS-a-and-WCSS-gradient-b-of-K-means-clustering-at-given-cluster-numbers_fig4_342705767&psig=AOvVaw2F3lN3SRpOEeaFHZMDbCJj&ust=1689778691849000&source=images&cd=vfe&opi=89978449&ved=0CBEQjRxqFwoTCKjbnqfCmIADFQAAAAAdAAAAABAE)

1. minimizing the distance between points in a cluster(intra).

2. maximizing the distance between clusters(inter).
"""

# use inertia method to allow sklearn to select the optimal cluster for us
kmeans.inertia_

# declare an empty list
wcss = []

for i in range (1,7):
  kmeans = KMeans(i,n_init='auto')
  kmeans.fit(x)
  wcss_iter = kmeans.inertia_
  wcss.append(wcss_iter)

# output wcss
wcss

"""#### **Plot the elbow chart:**"""

# assing the number of clusters representing the x-axis values
number_cluster = range(1,7)
# plot the number of clusters against wcss
plt.plot(number_cluster,wcss)
plt.plot(1.95,18000, marker="o", markersize=10, markeredgecolor="red", markerfacecolor="green")
plt.text(2.019, 18030, 'sub-optimal', fontsize = 10)
plt.plot(3,0, marker="o", markersize=10, markeredgecolor="red", markerfacecolor="yellow")
plt.text(3.002, 1000, 'optimal-k', fontsize = 10)
plt.title('The Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('Within-cluster Sum of Squares')
plt.show();